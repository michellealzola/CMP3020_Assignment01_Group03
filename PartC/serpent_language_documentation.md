# **Serpent+ Language Specification**

**Version 0.1**
*Copyright © 2025 Serpent+ Language Development Team*

---

## **1. Introduction**

The **Serpent+ Programming Language** is a **Python-inspired educational language** designed to demonstrate the fundamental stages of **lexical analysis, syntax parsing, and code interpretation**.

Serpent+ retains Python’s simplicity and readability but introduces explicit block terminators such as **`endfor`** to improve structural clarity. This explicit closure style assists both human readers and compiler tools in identifying the beginning and end of control structures.

The Serpent+ language is intended for use in programming language design, compiler theory, and software development education.

---

## **2. Lexical Structure**

A **Serpent+ program** is composed of a sequence of **tokens**.
Tokens are the smallest individual units of a program, classified as **keywords, identifiers, literals, operators, delimiters**, and **block terminators**.

### **2.1 Tokens**

Tokens in Serpent+ are generated by the Lexical Analyzer.
Each token consists of a **lexeme** (the actual text) and a **token type**.

#### **2.1.1 Keywords**

The following tokens are reserved as **keywords** and may not be used as identifiers:

```
def, if, else, elif, return, while, for, in, and, or, not, True, False, None, endfor
```

#### **2.1.2 Built-in Functions**

Serpent+ defines several built-in functions. Additional built-ins may be added in later versions.

```
print, len, range
```

#### **2.1.3 Identifiers**

An **identifier** is a name used to represent a variable, function, or list.
It must begin with a letter or underscore (`_`) and may contain alphanumeric characters or underscores thereafter.

```
Example:
sum, average, count, _temp
```

#### **2.1.4 Literals**

Literals represent fixed values in source code.

| Type           | Examples             | Description             |
| -------------- | -------------------- | ----------------------- |
| Integer        | `10`, `200`          | Whole numbers           |
| Floating-point | `3.14`, `0.001`      | Decimal numbers         |
| String         | `"Hello"`, `'World'` | Text enclosed in quotes |
| List           | `[1, 2, 3]`          | Collection of elements  |

#### **2.1.5 Operators**

Serpent+ supports arithmetic, comparison, and assignment operators.

| Category   | Operators                        | Description                |
| ---------- | -------------------------------- | -------------------------- |
| Arithmetic | `+`, `-`, `*`, `/`               | Standard arithmetic        |
| Assignment | `=`, `+=`, `-=`, `*=`, `/=`      | Assign or modify variables |
| Relational | `==`, `!=`, `<`, `>`, `<=`, `>=` | Comparisons                |
| Logical    | `and`, `or`, `not`               | Boolean operations         |

#### **2.1.6 Delimiters**

The following delimiters define grouping and block initiation:

```
( )  [ ]  ,  :
```

#### **2.1.7 Block Terminators**

Serpent+ introduces explicit block terminators.
Currently supported:

```
endfor
endif
```

---

## **3. Syntax and Semantics**

The Serpent+ language syntax is defined using **Extended Backus–Naur Form (EBNF)**.

### **3.1 Grammar Overview**

```
Program          ::= StatementList

StatementList    ::= { Statement [ NEWLINE ] }

Statement        ::= Assignment
                   | PrintStatement
                   | IfStatement
                   | ForStatement

Assignment       ::= Identifier "=" Expression

PrintStatement   ::= "print" "(" [ ArgumentList ] ")"
ArgumentList     ::= Expression { "," Expression }

IfStatement      ::= "if" Expression ":" NEWLINE
                     StatementList
                     [ "else" ":" NEWLINE
                       StatementList ]
                     "endif"

ForStatement     ::= "for" Identifier "in" ListLiteral ":" NEWLINE
                     StatementList
                     "endfor"

ListLiteral      ::= "[" [ Number { "," Number } ] "]"

Expression       ::= Term { ("+" | "-") Term }
Term             ::= Factor { ("*" | "/") Factor }
Factor           ::= Number
                   | Identifier
                   | String
                   | "(" Expression ")"
```

---

## **4. Program Structure**

A Serpent+ program consists of one or more statements executed sequentially.
Each statement must begin on a new line. Indentation is significant, just as in Python.

### **4.1 Control Structures**

#### **4.1.1 Conditional Statements**

Conditional statements allow execution of code blocks based on Boolean expressions.

**Syntax:**

```serpent+
if condition:
    # statements
else:
    # alternate statements
```

**Example:**

```serpent+
if len(list) != 0:
    print("List is not empty.")
else:
    print("List is empty.")
```

#### **4.1.2 Iteration Statements**

The **`for`** loop iterates over the elements of a list literal.
Unlike Python, Serpent+ requires an explicit **`endfor`** to close the loop.

**Syntax:**

```serpent+
for variable in list:
    # statements
endfor
```

### **4.2 Block Structure**

#### **4.2.1 General**

A *block* is a sequence of one or more statements introduced by a header that ends with a colon (`:`).
In **Serpent+**, the block structure is determined by **explicit terminators**, not by indentation or dedentation.

* **Indentation** is used only for readability and to promote consistent visual structure.
* **Dedentation**—that is, a reduction in indentation—is **not** interpreted as the end of a block.
* The structural boundaries of a block are defined solely by the appropriate **terminator keyword**.

The following terminators are recognized in version 0.1:

| Block Type  | Opening Keyword | Terminator |
| ----------- | --------------- | ---------- |
| For Loop    | `for`           | `endfor`   |
| Conditional | `if` / `else`   | `endif`    |

Future versions of Serpent+ may introduce additional explicit terminators such as `endwhile` and `endfunc`.

#### **4.2.2 For Blocks**

A `for` block begins with a `for` statement ending in a colon (`:`) and terminates explicitly with the keyword `endfor`.

**Syntax**

```serpent+
for <identifier> in <list>:
    <statements>
endfor
```

**Semantics**

1. The statements between `for` and `endfor` constitute the loop body.
2. The parser determines the end of the block by locating the matching `endfor`.
   Indentation has no effect on this determination.
3. Nested `for` blocks require nested `endfor` terminators. Each `endfor` closes the most recent unmatched `for`.
4. Inconsistent indentation inside the block does not alter program structure but may produce a style warning.

**Diagnostics**

* `Missing 'endfor'`
* `Stray 'endfor' (no matching 'for')`
* `Inconsistent indentation within 'for' block'` *(style warning)*

**Example**

```serpent+
for n in [1, 2, 3]:
    print(n)
endfor
```

#### **4.2.3 If / Else Blocks**

An `if` block and its optional `else` block are terminated by a single `endif` keyword.

**Syntax**

```serpent+
if <expression>:
    <then-statements>
[else:
    <else-statements>]
endif
```

**Semantics**

1. The `endif` keyword closes both the `if` and `else` blocks.
2. The parser uses `endif` —not dedentation—to determine block termination.
3. Indentation is recommended for clarity but is not part of the syntactic structure.

**Diagnostics**

* `Missing 'endif'`
* `Dangling 'else' (no matching 'if')`
* `Multiple 'else' for same 'if'`

**Example**

```serpent+
if len(list) != 0:
    print("List is not empty.")
else:
    print("List is empty.")
endif
```

---

### **4.2.4 Style Recommendations**

Although indentation has no structural significance in Serpent+, programmers are strongly encouraged to:

1. Indent each nested block consistently (e.g., four spaces).
2. Align each terminator (`endfor`, `endif`) vertically with its corresponding opening statement.
3. Avoid mixing tabs and spaces within the same file.

These conventions improve readability and help prevent logical errors even though the compiler does not rely on dedentation.



```
for <id> in <list> : 
    <statements>
endfor

```

---

## **5. Expressions**

Expressions are combinations of literals, variables, operators, and function calls that produce a value.

### **5.1 Arithmetic Expressions**

Arithmetic follows standard operator precedence:

```
*, /  → higher precedence  
+, -  → lower precedence
```

### **5.2 Example: Safe Average Calculation**

```serpent+
average = (sum / count) if count != 0 else 0
```

This inline conditional expression prevents division by zero by assigning `0` if `count` equals zero.

---

## **6. Example Program**

### **6.1 Full Example**

```serpent+
list = [1, 2, 3]
sum = 0
count = 0

if len(list) != 0:
    for n in list:
        sum += n
        count += 1
    endfor

    average = (sum / count) if count != 0 else 0
    print("The average of the list is", average)
else:
    print("The list is empty.")
```

### **6.2 Expected Output**

```
The average of the list is 2.0
```

If the list is empty:

```
The list is empty.
```

---

## **7. Error Handling**

### **7.1 Lexical Errors**

Lexical errors occur when a token is not recognized.

| Example                       | Message                                  |
| ----------------------------- | ---------------------------------------- |
| `price = $99`                 | `Error, $ is not recognized as a token`  |
| `inventory = inventory - 1))` | `Error, )) is not recognized as a token` |

### **7.2 Syntax Errors**

Syntax errors occur when statements do not follow language grammar.

| Example            | Message                      |
| ------------------ | ---------------------------- |
| Missing colon      | `Expected COLON, got RPAREN` |
| Missing endfor     | `Missing 'endfor'`           |
| Unexpected keyword | `Unexpected token KEYWORD`   |

---

## **8. Language Design Goals**

The Serpent+ language aims to:

1. Serve as a **bridge** between Python and compiler theory.
2. Promote clarity using **explicit block terminators**.
3. Enable **educational visualization** of lexical and syntax analysis.
4. Be **data-driven**, allowing grammar, tokens, and keywords to be edited through text files.
5. Support easy **expansion** for future block types such as `endif` and `endwhile`.

---

## **9. Future Enhancements**

| Feature                    | Description                                      |
| -------------------------- | ------------------------------------------------ |
| `endif`, `endwhile`        | Explicit closure for conditional and loop blocks |
| Comments                   | Single-line (`#`) and multi-line (`'''...'''`)   |
| String interpolation       | Embedding variables in string literals           |
| Runtime exception handling | Division-by-zero, type mismatch                  |
| Imports and functions      | Support for `def` and custom procedures          |

---

## **10. Implementation Overview**

| Component                 | Description                                                |
| ------------------------- | ---------------------------------------------------------- |
| **LexicalAnalyzer.py**    | Reads `.txt` rule files and tokenizes source code          |
| **SyntaxAnalyzer.py**     | Parses tokens based on grammar rules                       |
| **token_lexeme.txt**      | Defines regex patterns for token recognition               |
| **token_translation.txt** | Maps tokens to human-readable labels                       |
| **keywords.txt**          | Lists all language keywords                                |
| **builtin.txt**           | Lists built-in functions                                   |
| **main_window.py**        | PySide6-based GUI for code input and analysis              |
| **main.py**               | Entry point for running the application or compiled `.exe` |

---

## **11. Conclusion**

Serpent+ is a minimal yet extensible language designed to help students and developers **understand how programming languages work internally** — from lexical scanning to syntax parsing.

By blending **Python’s simplicity** with **explicit structural clarity**, Serpent+ demonstrates how small design changes (like the `endfor` keyword) can make language analysis more predictable and compiler design more intuitive.
